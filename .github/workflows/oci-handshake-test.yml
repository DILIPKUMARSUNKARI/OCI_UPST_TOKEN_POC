name: OCI Keyless Auth Test (DEBUG MODE)

on: [workflow_dispatch]

jobs:
  test-auth:
    runs-on: ubuntu-latest
    permissions:
      id-token: write   # REQUIRED for OIDC
      contents: read

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # --- STEP 1: Get Token & DEBUG THE REPO NAME ---
      - name: Get GitHub OIDC Token & Debug Subject
        id: get-id-token
        run: |
          # 1. Request the token
          token=$(curl -sLS "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${{ secrets.IDCS_CLIENT_ID }}" \
            -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" | jq -r '.value')
          
          # 2. Mask it so it doesn't leak in logs
          echo "::add-mask::$token"
          echo "id_token=$token" >> $GITHUB_OUTPUT

          # 3. DEBUG: DECODE AND PRINT THE TOKEN SUBJECT (The "sub" field)
          # This reveals EXACTLY what OCI is seeing (Case Sensitive!)
          echo "=========================================="
          echo "üïµÔ∏è DEBUG: DECODING TOKEN SUBJECT..."
          echo "------------------------------------------"
          
          # This complicated one-liner decodes the middle part of the JWT
          TOKEN_SUB=$(jq -R 'split(".") | .[1] | @base64d | fromjson | .sub' <<< "$token")
          
          echo "‚úÖ REAL TOKEN SUBJECT SENT BY GITHUB:"
          echo "$TOKEN_SUB"
          echo "------------------------------------------"
          echo "‚ö†Ô∏è COMPARE THE LINE ABOVE WITH YOUR OCI TRUST RULE!"
          echo "If OCI expects: 'repo:DILIP...' and this says 'repo:Dilip...', THAT IS YOUR BUG."
          echo "=========================================="

      # --- STEP 2: Generate Keys & Verify ---
      - name: Generate Session Key
        run: |
          mkdir -p .oci
          openssl genrsa -out .oci/session_key.pem 2048
          openssl rsa -pubout -in .oci/session_key.pem -out .oci/session_key_public.pem
          
          # Debug: Verify key was created
          if [ -f .oci/session_key_public.pem ]; then
            echo "‚úÖ Session key pair generated successfully."
          else
            echo "‚ùå ERROR: Session key generation failed."
            exit 1
          fi

          # Format key for API
          PUBLIC_KEY_ONE_LINE=$(cat .oci/session_key_public.pem | sed '1d;$d' | tr -d '\n')
          echo "PUBLIC_KEY=$PUBLIC_KEY_ONE_LINE" >> $GITHUB_ENV

      # --- STEP 3: The Handshake (With Verbose Output) ---
      - name: Exchange Token for OCI UPST
        id: exchange-token
        env:
          IDCS_URL: ${{ secrets.IDCS_DOMAIN_URL }}
          CLIENT_ID: ${{ secrets.IDCS_CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.IDCS_CLIENT_SECRET }}
          GH_TOKEN: ${{ steps.get-id-token.outputs.id_token }}
        run: |
          echo "=========================================="
          echo "üöÄ STARTING TOKEN EXCHANGE..."
          echo "Target URL: ${IDCS_URL}/oauth2/v1/token"
          echo "Client ID being used: ${CLIENT_ID}" 
          echo "(Secret is hidden, but variable is set)"
          echo "=========================================="

          # Run Curl with -v (verbose) to see the handshake details
          # Capture HTTP Status Code separately to debug 404 vs 401
          
          RESPONSE_BODY=$(curl -s -w "\n%{http_code}" -X POST "${IDCS_URL}/oauth2/v1/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -u "${CLIENT_ID}:${CLIENT_SECRET}" \
            -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
            -d "requested_token_type=urn:oci:token-type:oci-upst" \
            -d "subject_token=${GH_TOKEN}" \
            -d "subject_token_type=jwt" \
            -d "public_key=${PUBLIC_KEY}")

          # Split response body and status code
          HTTP_STATUS=$(echo "$RESPONSE_BODY" | tail -n1)
          JSON_BODY=$(echo "$RESPONSE_BODY" | sed '$d')

          echo "------------------------------------------"
          echo "üì° SERVER RESPONSE (HTTP $HTTP_STATUS)"
          echo "$JSON_BODY"
          echo "------------------------------------------"

          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå FAILURE DETECTED."
            echo "If HTTP 404: The 'sub' in the JWT does not match the 'rule' in OCI Trust."
            echo "If HTTP 401: Client ID/Secret is wrong."
            exit 1
          fi

          # If success, extract token
          UPST_TOKEN=$(echo "$JSON_BODY" | jq -r '.access_token')
          echo "::add-mask::$UPST_TOKEN"
          echo "upst_token=$UPST_TOKEN" >> $GITHUB_OUTPUT
          echo "‚úÖ UPST Token received successfully!"

      # --- STEP 4: Configure OCI CLI ---
      - name: Create OCI Config File
        env:
          TENANCY: ${{ secrets.OCI_TENANCY_OCID }}
          REGION: ${{ secrets.OCI_REGION }}
          UPST: ${{ steps.exchange-token.outputs.upst_token }}
        run: |
          echo "$UPST" > .oci/security_token
          
          cat <<EOF > .oci/config
          [DEFAULT]
          security_token_file=$(pwd)/.oci/security_token
          key_file=$(pwd)/.oci/session_key.pem
          tenancy=$TENANCY
          region=$REGION
          auth=security_token
          EOF
          
          chmod 600 .oci/config .oci/session_key.pem
          
          echo "‚úÖ OCI Config file created at $(pwd)/.oci/config"
          echo "debug: Listing .oci directory:"
          ls -l .oci/

      # --- STEP 5: Verify Auth Works ---
      - name: Verify Connection (List Regions)
        env:
          OCI_CONFIG_FILE: $(pwd)/.oci/config
        run: |
          echo "Testing OCI Connectivity..."
          oci iam region list --config-file .oci/config
